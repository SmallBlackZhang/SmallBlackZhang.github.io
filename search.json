[{"title":"Hello World","url":"/2021/04/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["Test"],"tags":["Test"]},{"title":"「善学善思」 —— JS数据类型","url":"/2021/05/20/js001/","content":"类型分类最新的 ECMAScript 标准定义了 8 种数据类型:分为原始数据类型（值类型）和引用数据类型（对象类型）最基本原始类型包括以下 7 个：\n\nNumber\nBoolean\nString\nNull(特殊)\nUndefined\nSymbol\nBigint(es2020新增)\n\n引用类型统称为 Object 类型,常用的Object 类型有以下 9 个：\n\nFunction\nArray\nDate\nMath\nRegExp\nMap\nSet\nJSON\nArrayBuffer\n\n值类型取值范围\n\n\n类型\n取值范围\n\n\n\nNumber\n-(2^53 -1) 到 2^53 -1, +Infinity，-Infinity 和 NaN\n\n\nBoolean\ntrue false\n\n\nString\n任意字符串\n\n\nNull\nnull\n\n\nUndefined\nundefined\n\n\nSymbol\n符号类型值是唯一的并且是不可修改的\n\n\nBigint\n仅在合理预期大于 2^53 的值时才使用 BigInt 值\n\n\n判断数据类型\n严格相等===\ntypeof\ninstanceof\nObject.prototype.toString.call\nconstructor\n\n如何判断 JS 的数据类型\n数据类型转换javaScript是一种弱类型语言，变量不受类型限制，所以在特定情况下我们需要对类型进行转换。「类型转换」分为显式类型转换和隐式类型转换。每种转换又分为原始类型转换和对象类型转换。谈谈 JS 中神奇的数据类型转换\n","categories":["javascript"],"tags":["js"]},{"title":"「善学善思」—— JS数据类型判断","url":"/2021/06/25/js002/","content":"使用严格相等符号===由于 Null 类型和 Undefined 的值都是唯一的，我们可以使用严格相等判断===来对两者进行判断\nlet aa = nulllet bb = undefinedconsole.log(aa === null) // trueconsole.log(bb === undefined) // true\n\n使用 typeof 运算符typeof是一元运算符，返回值为一个字符串类型。一般用来判断变量是什么数据类型。\ntypeof 10 // &#x27;number&#x27;typeof &quot;String&quot; // &#x27;string&#x27;typeof false // &#x27;boolean&#x27;typeof null // &#x27;object&#x27;typeof undefined // &#x27;undefined&#x27;typeof Symbol() // &#x27;symbol&#x27;typeof 10000n // &#x27;bigint&#x27;typeof function () &#123;&#125;) // &#x27;function&#x27;typeof []) / &#x27;object&#x27;typeof &#123;&#125;) / &#x27;object&#x27;\n\n\n1.对于原始数据类型，除 null 以外，均可以返回正确的结果。\n2.对于引用类型，除 function 以外，一律返回 object 类型。\n3.对于 null ，返回 object 类型。\n4.对于 function 返回 function 类型。\n\n\n为什么 typeof null 等于 Object?不同的对象在底层原理的存储是用二进制表示的，在 javaScript 中，如果二进制的前三位都为0 的话，系统会判定为是 Object 类型。null 的存储二进制全是 0，所以系统判定 typeof null 为 object 类型。\n\n使用 instanceof 关键字既然 typeof 对对象类型都返回 Object 类型情况的局限性，我们可以使用 instanceof关键字来对对象类型进行判断。instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，进而判断某个对象是不是另一个对象的实例。返回值的是一个布尔类型。\n使用： A instanceof B, instanceof 左侧 A 必须是对象, 才能找到它的原型链__proto__,instanceof 右侧 B 必须是函数, 函数才会 prototype原型属性// 当 A 为原始数据类型 instanceof 结果为 false // 当 B 不是函数 则报错 TypeError\nconsole.log(&#123;&#125; instanceof Object) // trueconsole.log([] instanceof Array) // trueconsole.log(function () &#123;&#125; instanceof Function) // trueconsole.log(new Map() instanceof Map) // trueconsole.log(new Set() instanceof Set) // trueclass A &#123;  constructor(name) &#123;    this.name = name  &#125;&#125;let a = new A(&quot;zzzzzxm&quot;)console.log(A instanceof Function) // trueconsole.log(a instanceof A) // trueconsole.log(a instanceof Function) // falseconsole.log(a instanceof Object) // true\n\n\n那么使用A instanceof B 发生了什么?a 会一直沿着隐式原型链__proto__向上查找直到 a.__proto__.__proto__ ...... === b.prototype 为止，如果找到则返回 true，也就是 a 为 b 的一个实例。否则返回 false，a 不是 b的实例。\n\n简单手写一个instanceof实现：\nfunction myInstanceof(left, right) &#123;  const baseType = [    &quot;number&quot;,    &quot;boolean&quot;,    &quot;string&quot;,    &quot;symbol&quot;,    &quot;bigint&quot;,    &quot;undefined&quot;,  ]  if (left === null || baseType.includes(typeof left)) &#123;    return false  &#125;  if (!right.prototype) &#123;    throw TypeError(`Right-hand side of &#x27;instanceof&#x27; is not callable`)  &#125;  let leftProto = left.__proto__  let rightProto = right.prototype  while (true) &#123;    if (leftProto === null) return false    if (leftProto === rightProto) return true    leftProto = leftProto.__proto__  &#125;&#125;console.log(myInstanceof(&#123;&#125;, Object)) // trueconsole.log(myInstanceof([], Array)) // trueconsole.log(myInstanceof(function () &#123;&#125;, Function)) // trueconsole.log(myInstanceof(new Map(), Map)) // trueconsole.log(myInstanceof(new Set(), Set)) // trueclass A &#123;  constructor(name) &#123;    this.name = name  &#125;&#125;let a = new A(&quot;zzzzzxm&quot;)console.log(myInstanceof(A, Function)) // trueconsole.log(myInstanceof(a, A)) // trueconsole.log(myInstanceof(a, Function)) // falseconsole.log(myInstanceof(0, Object)) // falseconsole.log(myInstanceof(null, Object)) // false\n\n到此我们可以得到结论\n\n判断 null 使用严格相等===\n判断原始数据类型（null 除外）使用 typeof\n判断引用数据类型使用 instanceof那么有没有一种方法不用区分原始数据类型和引用数据类型就能进行判断呢？Object.prototype.toString.call来了\n\n使用Object.prototype.toString.call在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。需要注意的是，但是它不能检测非原生构造函数的构造函数名。\nconst Opt = Object.prototype.toStringconsole.log(Opt.call(1)) // [object Number]console.log(Opt.call(&quot;string&quot;)) // [object String]console.log(Opt.call(false)) // [object Boolean]console.log(Opt.call(100n)) // [object BigInt]console.log(Opt.call(null)) // [object Null]console.log(Opt.call(undefined)) // [object Undefined]console.log(Opt.call(Symbol())) // [object Symbol]console.log(Opt.call(&#123;&#125;)) // [object Object]console.log(Opt.call([])) // [object Array]console.log(Opt.call(() =&gt; &#123;&#125;)) // [object Function]console.log(Opt.call(new Map())) // [object Map]console.log(Opt.call(new Set())) // [object Set]console.log(Opt.call(new Date())) // [object Date]//不能检测非原生构造函数的构造函数名class A &#123;  constructor(name) &#123;    this.name = name  &#125;&#125;let a = new A(&quot;zzzzzxm&quot;)function B(name) &#123;  this.name = name&#125;let b = new B(&quot;zzzzzxm&quot;)console.log(Opt.call(a)) // [object Object]console.log(Opt.call(b)) // [object Object]\n\n使用构造函数constructor当然还可以通过构造函数constructor进行判断\nlet bool = trueconsole.log(bool.constructor === Boolean) // truelet num = 10console.log(num.constructor === Number) // truelet bigint = 12121212121212nconsole.log(bigint.constructor === BigInt) // truelet str = &quot;zzzzzxm&quot;console.log(str.constructor === String) // truelet arr = []console.log(arr.constructor === Array) // truelet obj = &#123;&#125;console.log(obj.constructor === Object) // truelet fun = () =&gt; &#123;&#125;console.log(fun.constructor === Function) // truelet symbol = Symbol()console.log(symbol.constructor === Symbol) // truefunction Student(name, age) &#123;  this.name = name  this.age = age&#125;let student = new Student(&quot;zzzzzxm&quot;, 18)console.log(student.constructor === Student) // falseclass Person &#123;&#125;console.log(new Person().constructor === Person) // true\n\nundefined和null没有constructor属性constructor不能判断undefined和null，并且使用它是不安全的，因为constructor的指向是可以改变的\n最后萝卜青菜各有所爱，合理选择判断数据类型的方式，happy coding ~\n","categories":["javascript"],"tags":["js"]},{"title":"「善学善思」—— JS数据类型转换","url":"/2021/06/28/js003/","content":"数据类型转换javaScript是一种弱类型语言，变量不受类型限制，所以在特定情况下我们需要对类型进行转换。「类型转换」分为显式类型转换和隐式类型转换。每种转换又分为原始类型转换和对象类型转换。\n显式类型转换显式类型转换就是我们所说强制类型转换\nToBoolean 转换除了特殊的几个值 “”、 undefined、 NaN、 null、 false、 0 转换为 Boolean 为 false 之外，其他类型值都转换为 true。\nBoolean(&quot;&quot;)         // falseBoolean(undefined)  // falseBoolean(null)       // falseBoolean(NaN)        // falseBoolean(false)      // falseBoolean(0)          // falseBoolean(&#123;&#125;)\t\t    // trueBoolean([])\t\t    // true\n\nToString 转换\n\n\n数据类型\nString 类型\n\n\n\nString\n不转换\n\n\nNumber\n转换为数字对应的字符串\n\n\nBigint\n转换为数字对应的字符串\n\n\nBoolean\n转换为字符串 “true”和”false”\n\n\nnull\n转换为字符串 “null”\n\n\nundefined\n转换为字符串 “undefined”\n\n\nSymbol\n转换为 Symbol 对应的字符串\n\n\nObject\n执行 ToPrimitive(input,&#39;String&#39;)转换\n\n\nString(123);      // &quot;123&quot;String(true);     // &quot;true&quot;String(null);     // &quot;null&quot;String(undefined);// &quot;undefined&quot;String([1,2,3])   // &quot;1,2,3&quot;String(&#123;&#125;);\t\t  // &quot;[object Object]&quot;String(Symbol(&quot;zzzzzxm&quot;)) //&quot;Symbol(zzzzzxm)&quot;\n\nToNumber 转换\n\n\n数据类型\n数字类型\n\n\n\nNumber\n不转换\n\n\nString\n字符串中只有数字转换为对应的数字,空串转换为 0，其他转换为 NaN\n\n\nBoolean\ntrue 转换为 1 false 转换为 0\n\n\nnull\n0\n\n\nundefined\nNaN\n\n\nBigint\n不建议转换\n\n\nSymbol\n报错 TypeError: Cannot convert a Symbol value to a number\n\n\nObject\n先执行 ToPrimitive(input,&#39;Number&#39;)转换为基本数据类型,再执行 ToNumber转换为 Number 类型\n\n\nNumber(&#x27;&#x27;);        // 0Number(&#x27;10&#x27;);      // 10Number(&#x27;10a&#x27;);       // NaNNumber(null);      // 0Number(undefined); // NaNNumber(true);      // 1Number(false);     // 0Number([]);        // 0Number([10]);     // 10Number([1,2]);     // NaNNumber(&#123;&#125;);     // NaN\n\nToPrimitive 转换引用类型在转原始类型的时候，会根据ToPrimitive 算法规则转换。//以简单的 function 做例子来描述 ToPrimitive 算法\nfunction ToPrimitive(input, type) {}\n\n如果 input 为基本数据类型 直接返回 input 本身\n如果 input 为引用数据类型\n如果 type 有值，执行下一步\n如果 type 没有传值\ninput 为 Date 类型 type = String\n其他类型 type = Number\n\n\n\n\n根据 type 类型执行 toString 和 valueOf\ntype 为 string\n调用 input 对象的 toString()方法，如果值是原值则返回\n否则，调用 input 对象的 valueOf()方法，如果值是原值则返回\n否则，抛出 TypeError 错误\n\n\ntype 为 number\n调用 input 对象的 valueOf()方法，如果值是原值则返回\n否则，调用 input 对象的 toString()方法，如果值是原值则返回\n否则，抛出 TypeError 错误\n\n\n\n\n\n\n拓展：内置的 valueOf()和 toString()是可以进行重写的\n\n// 使a==1&amp;a==2&amp;a==3为true?const a = &#123;  i: 1,  valueOf: function () &#123;    return this.i++  &#125;,&#125;if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) &#123;  console.log(&quot;ok&quot;)  // ok&#125;\n\n想完全理解上面的题目，你还需要对隐式类型转换需要一定的了解\n隐式类型转换隐式类型转换不需要人为的强制类型转换，javaScript 自动将类型转换为需要的类型，所以称之为隐式类型转换.\n\n怎样会发生隐式类型转换?因为javaScript并没有类型声明，所以任意两个变量或字面量，都可以进行运算，不同类型之间的数据运算会将数据变为相同类型然后进行运算，这就产生了隐式类型转换。\n\n算数运算符相关类型转换\n加法(+)\n减法(-)\n乘法(*)\n除法(/)\n取余(%)\n一元正值(+)\n一元负值(-)\n自增(++)\n自减(–)\n\n特殊的加法运算符js 的加法(+)运算符既可以计算两个数的和也能实现字符串的拼接，当两个不同类型值通过加法(+)运算符运算符连接时又会产生各种各样的隐式类型转换那么任意两个变量或字面量通过加法(+)运算符连接时，怎么进行隐式类型转换呢\n\na+b\n两边同时执行 ToPrimitive转换 即 ToPrimitive(a)+ToPrimitive(b)\n判断 ToPrimitive(a)和 ToPrimitive(b)得到的结果有没有 String 类型\n有 String 类型\n两个数再执行 ToString() 即 ToString(ToPrimitive(a))+ToString(ToPrimitive(b))\n进行拼接 得到拼接的字符串结果\n\n\n没有 String 类型\n两个数再执行 ToNumber() 即 ToNumber(ToPrimitive(a))+ToNumber(ToPrimitive(b))\n进行加法运算 得到的数字结果\n\n\n\n\n\n\n举几个栗子\n\n“number” + 15\n两边同时 ToPrimitive 转换，因为都是基本数据类型 =&gt; “number” + 15\n有 String 类型 两边再执行 ToString 转换 =&gt; “number” + “15”\n拼接字符串 =&gt; “number15”\n\n\ntrue + false\n两边同时 ToPrimitive 转换 =&gt; true + false\n两边再执行 ToNumber 转换 =&gt; 1 + 0\n进行加法运算 =&gt; 1\n\n\nnew Date() + true\n两边同时 ToPrimitive 转换 =&gt; “Wed Jun 30 2021 11:30:58 GMT+0800 (新加坡标准时间)” + true\n两边再执行 ToString 转换 =&gt; “Wed Jun 30 2021 11:30:58 GMT+0800 (新加坡标准时间)” + “true”\n拼接字符串 =&gt; “Wed Jun 30 2021 11:30:58 GMT+0800 (新加坡标准时间)true”\n\n\n[]+{}\n两边同时 ToPrimitive 转换 =&gt; “” + “[object Object]”\n两边再执行 ToString 转换 =&gt; “” + “[object Object]”\n拼接字符串 =&gt; “[object Object]”\n\n\n\n\n其他算数运算符对运算符相关变量或字面量，执行ToNumber(ToPrimitive(input,&#39;Number&#39;)),然后进行算数运算\n\n举几个栗子\n\n“number” - 15\n两边同时 ToNumber(ToPrimitive(input,’Number’))转换 =&gt; NaN - 15\n进行减法运算 =&gt; NaN\n\n\ntrue * false\n两边同时 ToNumber(ToPrimitive(input,’Number’))转换 =&gt; 1 * 0\n进行运算 =&gt; 0\n\n\nnew Date() / false\n两边同时 ToNumber(ToPrimitive(input,’Number’))转换 =&gt; 1625024813205 / 0\n进行运算 =&gt; Infinity\n\n\n+{}\nToNumber(ToPrimitive(input,’Number’)) =&gt; + NaN\nNaN\n\n\n\n\n比较运算符相关类型转换\n等于(==)\n不等于(!=)\n全等(===)\n不全等(!==)\n大于(&gt;)\n小于(&lt;)\n大于等于(&gt;=)\n小于等于(&lt;=)\n\n全等(===)和不全等(!==)全等(===)和不全等(!==)运算符两边的数据不会进行隐式数据类型转化\n\n1、如果类型不同，就不相等\n2、如果两个都是数值，并且值相等，那么[相等]；!例外的是，如果其中至少一个是 NaN，那么不相等NaN与任何数值比较结果都是false。\n3、如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等 。\n4、如果两个值都是 true，或者都是 false，那么相等。\n5、如果两个值都引用同一个对象或函数，那么相等；否则不相等。\n6、如果两个值都是 null，或者都是 undefined，那么相等。\n\n\n举几个栗子\n\ntrue === 1 // false\ntrue === true / true\n+0 === -0 // true\nNaN === NaN // false\n{}==={} // false\nnull === null // true\nnull === undefined // false\n\n\n等于(==)和不等于(!=)\n如果类型相同\n不进行隐式类型转化，执行全等于比较\n\n\n如果类型不同\n先对引用类型数据执行 ToPrimitive，再判断类型是否相同\n如果类型相同，执行全等于比较\n类型不同，同时对两个数据执行 ToNumber 转换,然后进行数字大小比较\n\n\n\n\n举几个栗子\n\n“true” == true\nNaN == 1\nfalse\n\n\n[“x”] == “x”\n“x” == “x”\ntrue\n\n\n[] == ![]\n[] == false\n“” == false\n0 == 0\ntrue\n\n\n[undefined] == false\n“” == false\n0 == 0\ntrue\n\n\n\n\n其他比较运算符\n对引用类型数据进行ToPrimitive(input,&#39;Number&#39;)转换\n如果两边都是 String 类型\njavascript字符串在进行大小比较时，会根据第一个不同的的 ASCII 码值进行比较\n如果这一位相同，取下一位字符的 ASCII 码值进行比较\n\n\n否则，执行ToNumber转换,然后进行数字比较\n\n\n举几个栗子\n\n[“1”] &gt; false\n1 &gt; 0\ntrue\n\n\nnew Date() &gt; “1609430400000” （2021-01-01 时间戳）\n1625031825645 &gt; 1609430400000\ntrue\n\n\n‘2021-2’ &lt; ‘2021-11’\n前 5 位字符（2021-）的 ASCII 值一直相同\n对第 6 位字符的 ASCII 值比较 ‘2’&lt;’1’\nfalse\n\n\n\n\n逻辑运算符相关类型转换\n逻辑与 (&amp;&amp;)\n逻辑或 (||)\n逻辑非 (!)\n\n对运算符相关变量或字面量，执行ToBoolean\n\n举几个栗子\n\nif( [undefined] &amp;&amp; [null] )\nif(true &amp;&amp; true)\nif(true)\n\n\nif( 0 || “0” &amp;&amp; {} )\nif((false || true) &amp;&amp; {})\nif(true &amp;&amp; true)\nif(true)\n\n\n!{}\n!true\nfalse\n\n\n\n\n最后到这，基本上隐式类型转换就差不多了，可以找题目熟练起来了\n\n++[[]][+[]]+[+[ ]] 结果是什么？\n\n","categories":["javascript"],"tags":["js"]},{"title":"「善学善思」—— JS预编译","url":"/2021/07/03/js004/","content":"00. JS  是解释型编程语言MDN  上明确的说，JavaScript是一个轻量级的、解释型的、面向对象的、将函数视为一级公民的语言。\n\n电脑能认得的是二进制数，不能够识别高级语言。所有高级语言在电脑上执行都需要先转变为机器语言。但是高级语言有两种类型：编译型语言和解释型语言。\n\n\n编译型语言先要进行编译，然后转为特定的可执行文件，这个可执行文件是针对平台的（CPU  类型），可以这么理解你在  PC  上编译一个  C  源文件，需要经过预处理，编译，汇编等等过程生成一个可执行的二进制文件。当你需要再次运行改代码时，不需要重新编译代码，只需要运行该可执行的二进制文件。优点，编译一次，永久执行。还有一个优点是，你不需要提供你的源代码，你只需要发布你的可执行文件就可以为客户提供服务，从而保证了你的源代码的安全性。但是，如果你的代码需要迁移到  linux、ARM  下时，这时你的可执行文件就不起作用了，需要根据新的平台编译出一个可执行的文件。这也就是多个平台需要软件的多个版本。缺点是，跨平台能力差。\n\n\n解释型语言需要一个解释器，在源代码执行的时候被解释器翻译为一个与平台无关的中间代码，解释器会把这些代码翻译为及其语言。打个比方，编译型中的编译相当于一个翻译官，它只能翻译英语，而且中文文章翻译一次就不需要重新对文章进行二次翻译了，但是如果需要叫这个翻译官翻译德语就不行了。而解释型语言中的解释器相当于一个会各种语言的机器人，而且这个机器人回一句一句的翻译你的语句。对于不同的国家，翻译成不同的语言，所以，你只需要带着这个机器人就可以。解释型语言的有点是，跨平台，缺点是运行时需要源代码，知识产权保护性差，运行效率低\n\n01. JS  引擎运行三部曲1.  语法分析语法分析很简单，就是引擎检查你的代码有没有什么低级的语法错误；有错误代码将无法运行。\n2.  预编译预编译简单理解就是在运行代码之前的准备工作，js  会在内存中开辟一些空间，提前存放好用户代码中涉及的变量与函数\n3.  解释执行将代码一行一行解析为机器能识别的语言，执行代码。\n02. JS  预编译什么时候发生-  脚本代码块  script  执行前发生预编译，生成GO对象(Global Object) 也有人称为全局执行上下文\n-  函数调用执行前发生预编译，生成AO对象(Active Object) 也有人称为函数执行上下文\n03.  预编译前奏- imply global  即暗示全局变量，如果未经声明就赋值，则此变量就位全局变量所有。(全局域就是  Window)\n-  一切声明的全局变量，全是  window  的属性；\n举个例子\n    var a = 10;        b = 20;    function fn() &#123;      c = 30    &#125;    fn()    console.log(window.a, window.b, window.c)  // 10,20,30\n\n1.  声明全局变量  a=10 =&gt; window.a = 10\n2. b = 20 ,暗示全局变量  =&gt; window.b = 20\n3. fn()调用   未找到局部变量，则暗示全局变量  =&gt; window.c =30\n04. JS  预编译过程脚本代码块  script  执行前-  创建了  GO  全局对象（Global Object）\n-  查找变量声明，作为  GO  属性，值赋予  undefined (变量提升) ；\n-  查找函数声明，作为  GO  属性，值赋予函数体  （函数提升）；\n-  执行代码\n\n先来区分理解一下这 2  个概念:  变量声明  var  关键字  var a = ‘a’ （let const  声明的变量不会提升）  函数声明  function  关键字  function(){}… (var a = function(){}  是变量声明不是函数声明)  举个例子：\n\n    console.log(a)  // undefined    console.log(b)  // ƒ b() &#123;&#125;    var a = &quot;zzzzzxm&quot;    function b() &#123;&#125;    console.log(a)  // &quot;zzzzzxm&quot;    console.log(b)  // ƒ b() &#123;&#125;\n\n上述代码执行：\n1.  开始脚本代码块 script 执行前的预编译，创建  GO =&gt; GO:{}\n2.  查找变量声明，作为  GO  属性，值赋予  undefined =&gt;GO: { a:undefined }\n3.  查找函数声明，作为  GO  属性，值赋予函数体  =&gt; GO: { a:undefined, b:function b(){}}\n4. 预编译结束，执行代码console.log(a)从  GO  中查找  GO.a  打印  undefined\n5.  执行代码console.log(b)从  GO  中查找  GO.b  打印  ƒ b() {}\n6.  执行代码  a = &quot;zzzzzxm&quot; =&gt; GO.a = “zzzzzxm”\n7.  执行代码  console.log(a)  从  GO  中查找  GO.a  打印”zzzzzxm”\n8.  执行代码  console.log(b) 从  GO  中查找  GO.b  打印  ƒ b() {}\n函数调用执行前-  创建函数的  AO  对象\n-  查找形参和变量声明，值赋予  undefined\n-  实参值赋给形参\n-  查找函数声明，值赋予函数体\n-  执行代码\n举个例子：\nconsole.log(a)  // undefineda = 1function test(c) &#123;  console.log(a, b, c)  //1,undefined,f c()&#123;&#125;  if (a) &#123;    a = &quot;a&quot;    var b = &quot;b&quot;  &#125;  c = &quot;c&quot;  function c() &#123;&#125;  console.log(a, b, c) // a,b,c&#125;var atest(3)\n\n上述代码执行预编译:\n\n开始脚本代码块 script 执行前的预编译，创建 GO =&gt; GO:{}\n\n查找变量声明 var a 作为  GO  属性，值赋予  undefined =&gt; GO: { a:undefined }\n\n查找函数声明 function test() 作为  GO  属性，值赋予函数体  =&gt; GO: { a:undefined,b:function test() }\n\n预编译结束,执行语句console.log(a) 从 GO 中取 a，打印undefined\n\n执行语句a = 1 为 GO 中的 a 赋值 =&gt; GO: { a:1,b:function test() }\n\n执行语句test(3),\n\n开始函数调用执行前的预编译,创建函数 test 的 AO =&gt; AO:{}\n\n查找形参c和变量声明var b，值赋予  undefined =&gt; AO:{c:undefined,b:undefined}\n\n实参赋值给形参 将test(3)中传入的3赋值给c =&gt; AO:{c:3,b:undefined}\n\n查找函数声明function c，值赋予函数体 =&gt; AO:{c:function c(),b:undefined}\n\n预编译结束, 执行函数内代码 console.log(a, b, c) ，从 AO 中取a,没有，然后去 GO 中取a,得到a=1(此处涉及作用域链相关知识);从 AO 中取b,得到b=undefined;从 AO 中取c,得到c=function c(); 打印结果1,undefined,f c()&#123;&#125;\n\n执行代码if(a),从 AO 中取a,没有，然后去 GO 中取a,得到a=1,进入判断\n\n执行代码a=&quot;a&quot;,从 AO 中取a,没有，然后去 GO 中取a,修改a的值为”a” =&gt; GO:{a:”a”,b:function test() }\n\n执行代码b=&quot;b&quot;,从 AO 中取b,修改b的值为”b” =&gt; AO:{c:function c(),b:”b”}\n\n执行代码c=&quot;c&quot;,从 AO 中取c,修改c的值为”c” =&gt; AO:{c:”c”,b:”b”}\n\n执行代码console.log(a, b, c),从 AO 中取a,没有，然后去 GO 中取a,得到a=”a”(此处涉及作用域链相关知识);从 AO 中取b,得到b=”b”;从 AO 中取c,得到c=”c”; 打印结果a,b,c\n\n函数执行结束，销毁函数的 AO\n\n\n05 预编译小结\n预编译发生时间-  脚本代码块 script 执行前发生预编译，生成GO对象(Global Object) 也有人称为全局执行上下文-  函数调用执行前发生预编译，生成AO对象(Active Object) 也有人称为函数执行上下文\n预编译过程（脚本代码块  script  执行前）-  创建了  GO  全局对象（Global Object）-  查找变量声明，作为  GO  属性，值赋予  undefined (变量提升) ；-  查找函数声明，作为  GO  属性，值赋予函数体  （函数提升）；-  执行代码\n预编译过程（函数执行前）-  创建函数的  AO  对象-  查找形参和变量声明，值赋予  undefined-  实参值赋给形参-  查找函数声明，值赋予函数体-  执行代码\n预编译注意事项\n预编译阶段发生变量声明和函数声明，没有初始化行为（赋值），匿名函数不参与预编译 ；\n只有在解释执行阶段才会进行变量初始化 ；- imply global  即暗示全局变量，如果未经声明就赋值，则此变量就位全局变量所有。(全局域就是  Window)-  一切声明的全局变量，全是  window  的属性；\n\n","categories":["javascript"],"tags":["js"]},{"title":"「善学善思」—— JS作用域与作用域链","url":"/2021/07/03/js005/","content":"什么是作用域先上一段代码\nfunction fn1() &#123;       var a = 1     &#125;     function fn2() &#123;       var b = 2       console.log(a)     &#125;     // console.log(b)    //  fn2()\n\n以上代码运行语句console.log(b)会报引用错误Uncaught ReferenceError: b is not defined执行语句fn2()会报引用错误Uncaught ReferenceError: a is not defined为什么会这样呢？\n我们可以简单的将作用域理解为可访问变量，对象，函数的集合，决定代码区域中变量和其他资源的可见性。这个集合内的数据只允许内部访问，不允许外部访问。所以我们在运行语句时才会提示变量引用错误。作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。\n全局作用域在代码中任何地方都能访问到全局作用域中的变量，对象，函数等全局作用域的产生要结合预编译过程理解，\n\n脚本代码块  script  执行前会发生预编译创建 GO\n将 window/document/this 等作为 GO 的属性，\n将代码中声明在最外层的变量作为 GO 的属性，赋值 undefined\n将代码中声明在最外层的函数作为 GO 的属性，赋值函数体\n将 GO 设置为全局作用域\n\n一般来说以下几种情形拥有全局作用域：\n\n最外层函数 和在最外层函数外面定义的变量拥有全局作用域\n所有末定义直接赋值的变量自动声明为拥有全局作用域（imply global  即暗示全局变量，如果未经声明就赋值，则此变量就位全局变量所有）\n所有 window 对象的属性拥有全局作用域ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。\n\n函数作用域函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。\nfunction a() &#123;    var a = &quot;zzzzzxm&quot;;    function b() &#123;        console.log(b);    &#125;    b();&#125;console.log(a); //脚本错误b(); //脚本错误\n\n作用域是分层的，内层作用域可以访问外层作用域的变量,我们看个例子:\n\n1 是全局作用域，有标识符 foo；\n2 是函数作用域 foo，有标识符 a,bar,b；\n3 是函数作用域 bar，仅有标识符 c。\n\n函数 bar 中不仅可以访问到自己代码块的变量 c,还能访问到 foo,a,b 这是什么原理呢？这就涉及到函数作用域链了.\n函数作用域链 ※众所周知，js 中有句话，叫做万物皆对象。函数作为 js 中的一种数据类型，也属于对象类型。对象就有对象的属性，比如length/name/prototype等。这些属性成为对象的显式属性，可以通过.符号来访问。在 js 中，还有许多 js 引擎内部用来存储数据的隐式属性，这些隐式属性是无法访问的，但也是 js 运行必不可少的。其中我们常说的函数作用域就是js引擎在函数创建时添加到函数内部的隐式属性，记作 [[ scope ]]\n函数的[[ scope ]]属性为函数的作用域，存储的值为该函数的作用域链，而作用域链本质上就是GO AO组成的链式存储结构举个详细的栗子，看不懂不存在的~\nfunction a() &#123;      console.log(&quot;first&quot;, a, b, c)      function b() &#123;        var b = 2        console.log(&quot;second&quot;, a, b, c)      &#125;      var a = 1      b()      console.log(&quot;third&quot;, a, b, c)    &#125;    var c = 3    a()    console.log(&quot;last&quot;, a, b, c)\n\n\n代码块执行，系统进行预处理,生成全局执行上下文 GO 作为全局作用域\n变量声明 c 提升 赋值 undefined GO.c =undefined\n函数 function a 声明提升，赋值函数体，同时生成函数 a 的作用域 GO.a = function a\n执行全局代码 c =3 =&gt; GO.c = 3\n执行代码a()\n进行函数 a 执行前预处理，生成函数 a 的执行期上下文 AO\n函数 a 中变量 a 提升，赋值 undefined AO.a =undefined\n函数 a 中函数 b 声明提升，赋值函数体，同时生成函数 b 的作用域 AO.b = function b\n执行代码console.log(&quot;first&quot;, a, b, c)。此时处在函数 a 的执行期，在函数 a 的作用域链上查找 a,b,c。变量查找是从作用域链顶部自上而下查找,打印结果first undefined f b() 3\n执行代码a =1 , =&gt; 函数 a 的 AO.a = 1\n执行代码b()\n进行函数 b 执行前预处理，生成函数 b 的执行期上下文 AO\n函数 b 中的变量 b 提升赋值 undefined AO.b = undefined\n执行代码b=2 AO.b = 2\n执行代码 console.log(&quot;second&quot;, a, b, c)，此时处在函数 b 的执行期，在函数 b 的作用域链上查找 a,b,c。变量查找是从作用域链顶部自上而下查找,打印结果second 1 2 3\n函数 b 执行结束，函数 b 的执行期上下文 AO 销毁\n执行代码 console.log(&quot;third&quot;, a, b, c)，此时处在函数 a 的执行期，在函数 a 的作用域链上查找 a,b,c。变量查找是从作用域链顶部自上而下查找,打印结果third 1 f b() 3\n函数 a 执行结束，函数 a 的执行期上下文 AO 销毁。此时函数 b没有其他引用，随函数 a 的 AO 同时销毁。\n执行代码 console.log(&quot;last&quot;, a, b, c)，此时处在全局代码的执行期，在全局作用域 GO 上查找 a,b,c。全局作用域中不存在变量 b,就会抛出引用错误Uncaught ReferenceError: b is not defined\n代码执行结束\n\n块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。\nvar tmp = new Date();function f() &#123;  console.log(tmp);  if (false) &#123;    var tmp = &#x27;hello world&#x27;;  &#125;&#125;f(); // undefined\n\n上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于函数f执行时（前一刻）的预处理进行了变量提升，导致看起来的结果是内层的 tmp 变量覆盖了外层的 tmp 变量。第二种场景，用来计数的循环变量泄露为全局变量。\nvar s = &#x27;hello&#x27;;for (var i = 0; i &lt; s.length; i++) &#123;  console.log(s[i]);&#125;console.log(i); // 5\n\n上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。\nES6 的到来，为我们提供了块级作用域,可通过新增命令 let 和 const 来体现。\nfunction f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;\n\n上面的函数有两个代码块，都声明了变量 n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用 var 定义变量 n，最后输出的值才是 10。\n块级作用域就是包含在{…}中的作用域。在这个作用域中，拥有着和函数作用域相同的行为。\n注意：块级作用域的暂时死区（temporal dead zone，简称 TDZ）\nvar tmp = 123;if (true) &#123;  tmp = &#x27;abc&#x27;; // ReferenceError  let tmp;&#125;\n\n只要块级作用域内存在let 命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。\n上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\nES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。举个例子：\nif (true) &#123;  // TDZ开始  tmp = &#x27;abc&#x27;; // ReferenceError  console.log(tmp); // ReferenceError  let tmp; // TDZ结束  console.log(tmp); // undefined  tmp = 123;  console.log(tmp); // 123&#125;\n\n上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。\n“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。\ntypeof x; // ReferenceErrorlet x;\n","categories":["javascript"],"tags":["js"]}]